/**
 * Generic Cron Dispatcher (PocketHost friendly)
 *
 * Configure ONE PocketHost Webhook to call:
 *   /api/webhooks/cron?token=YOUR_SECRET
 * on a minutely schedule: * * * * * (UTC).
 *
 * This dispatcher will run any tasks whose schedule condition returns true
 * for the current UTC time. Add/modify tasks here without touching PocketHost.
 */

$app?.onBeforeServe?.((e) => {
  const path = '/api/webhooks/cron';

  // Tiny schedule helpers (UTC-based)
  const Sched = {
    everySeconds: (n, d) => d.getUTCSeconds() % n === 0,
    everyMinutes: (n, d) => d.getUTCMinutes() % n === 0,
    everyHours: (n, d) => d.getUTCHours() % n === 0 && d.getUTCMinutes() === 0,
    atUTC: (h, m, d) => d.getUTCHours() === h && d.getUTCMinutes() === m,
  };

  // Build task list dynamically from environment for flexibility
  const buildTasks = () => {
    const enabled = String($app.env('CRON_ENABLE_AUTO_POSTS') || '').toLowerCase() === 'true';
    const interval = Math.max(
      1,
      parseInt(String($app.env('CRON_POSTS_INTERVAL_MINUTES') || '1'), 10) || 1,
    );

    /** @type {Array<{ key: string; when: (d: Date) => boolean; run: (d: Date) => Promise<void> }>} */
    const list = [
      {
        key: 'auto-posts',
        when: (d) => enabled && Sched.everyMinutes(interval, d),
        run: async () => {
          const nowIso = new Date().toISOString();
          const rec = await $app.db().create('posts', {
            title: `Automated Post @ ${nowIso}`,
            content: `Generated by cron dispatcher at ${nowIso}`,
            published: true,
            // ensure value exists in your select options or remove this
            tags: ['tech'],
          });
          console.log('✅ cron task: created post', rec?.id || nowIso);
        },
      },
      // Example variations:
      // {
      //   key: 'daily-archive-2am-utc',
      //   when: (d) => Sched.atUTC(2, 0, d),
      //   run: async () => { /* ... */ },
      // },
    ];

    return list;
  };

  const handler = async (c) => {
    // auth with secret
    let token = c.request.headers.get('X-Webhook-Token');
    if (!token) {
      try {
        const url = new URL(c.request.url);
        token = url.searchParams.get('token');
      } catch (_) {}
    }
    const expected = $app.env('CRON_TOKEN');
    if (!expected || token !== expected) {
      return c.json(401, { error: 'unauthorized' });
    }

    const tasks = buildTasks();
    const now = new Date();
    const ran = [];
    const errors = [];

    for (const t of tasks) {
      try {
        if (typeof t.when !== 'function' || t.when(now)) {
          // best-effort isolation per task
          await Promise.resolve(t.run(now));
          ran.push(t.key);
        }
      } catch (err) {
        console.error(`❌ cron task failed: ${t.key}`, err);
        errors.push({ key: t.key, error: err?.message || String(err) });
      }
    }

    return c.json(200, { ok: true, ran, errors });
  };

  e.router.add('POST', path, handler);
  e.router.add('GET', path, handler);
  console.log(`✅ Cron dispatcher route registered (onBeforeServe): ${path}`);
});

// PocketHost compatibility: also register via routerAdd if provided
try {
  const path = '/api/webhooks/cron';
  if (typeof routerAdd === 'function') {
    // reuse the same logic by creating a local handler wrapper
    const Sched = {
      everySeconds: (n, d) => d.getUTCSeconds() % n === 0,
      everyMinutes: (n, d) => d.getUTCMinutes() % n === 0,
      everyHours: (n, d) => d.getUTCHours() % n === 0 && d.getUTCMinutes() === 0,
      atUTC: (h, m, d) => d.getUTCHours() === h && d.getUTCMinutes() === m,
    };

    const getEnv = (key) => {
      try { if (typeof $app !== 'undefined' && typeof $app.env === 'function') return $app.env(key); } catch {}
      try { if (typeof secrets !== 'undefined' && typeof secrets.get === 'function') return secrets.get(key); } catch {}
      try { if (typeof Deno !== 'undefined' && Deno.env?.get) return Deno.env.get(key); } catch {}
      try { if (typeof process !== 'undefined' && process.env) return process.env[key]; } catch {}
      return undefined;
    };

    const buildTasks = () => {
      const enabled = String(getEnv('CRON_ENABLE_AUTO_POSTS') || '').toLowerCase() === 'true';
      const interval = Math.max(1, parseInt(String(getEnv('CRON_POSTS_INTERVAL_MINUTES') || '1'), 10) || 1);
      return [
        {
          key: 'auto-posts',
          when: (d) => enabled && Sched.everyMinutes(interval, d),
          run: async () => {
            const nowIso = new Date().toISOString();
            const rec = await $app.db().create('posts', {
              title: `Automated Post @ ${nowIso}`,
              content: `Generated by cron dispatcher at ${nowIso}`,
              published: true,
              tags: ['tech'],
            });
            console.log('✅ cron task: created post', rec?.id || nowIso);
          },
        },
      ];
    };

    const handler = async (ctx) => {
      // auth
      let token = ctx.request?.headers?.get?.('X-Webhook-Token');
      if (!token) {
        try { const url = new URL(ctx.request.url); token = url.searchParams.get('token'); } catch {}
      }
      const expected = getEnv('CRON_TOKEN');
      if (expected && token !== expected) {
        return ctx.json?.(401, { error: 'unauthorized' }) || { status: 401 };
      }

      const tasks = buildTasks();
      const now = new Date();
      const ran = []; const errors = [];
      for (const t of tasks) {
        try {
          if (typeof t.when !== 'function' || t.when(now)) {
            await Promise.resolve(t.run(now));
            ran.push(t.key);
          }
        } catch (err) {
          console.error(`❌ cron task failed: ${t.key}`, err);
          errors.push({ key: t.key, error: err?.message || String(err) });
        }
      }
      return ctx.json?.(200, { ok: true, ran, errors }) || { status: 200 };
    };

    routerAdd('POST', path, handler);
    routerAdd('GET', path, handler);
    console.log(`✅ Cron dispatcher route registered (routerAdd): ${path}`);
  }
} catch {}
