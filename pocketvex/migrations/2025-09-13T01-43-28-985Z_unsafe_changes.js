/**
 * Migration: 2025-09-13T01:43:28.985Z
 * Generated by PocketVex Dev Server
 */

export const up = async (pb) => {
  // Unsafe operations requiring manual review
  // 1. Remove index from collection 'courses': CREATE UNIQUE INDEX `idx_courses_slug` ON `courses` (`slug`)
  // 2. Remove index from collection 'courses': CREATE INDEX `idx_courses_status_visibility` ON `courses` (
  //   `status`,
  //   `visibility`
  // )
  // 3. Remove index from collection 'courses': CREATE INDEX `idx_courses_author` ON `courses` (`author`)
  // 4. Remove index from collection 'modules': CREATE INDEX `idx_modules_course` ON `modules` (`course`)
  // 5. Remove index from collection 'modules': CREATE INDEX `idx_modules_order` ON `modules` (
  //   `course`,
  //   `order`
  // )
  // 6. Remove index from collection 'lessons': CREATE INDEX `idx_lessons_module` ON `lessons` (`module`)
  // 7. Remove index from collection 'lessons': CREATE INDEX `idx_lessons_order` ON `lessons` (
  //   `module`,
  //   `order`
  // )

  console.log('Running migration: 2025-09-13T01-43-28-985Z');

  const targets = [
    {
      collection: 'courses',
      indexes: [
        'CREATE UNIQUE INDEX `idx_courses_slug` ON `courses` (`slug`)',
        'CREATE INDEX `idx_courses_status_visibility` ON `courses` (\n  `status`,\n  `visibility`\n)',
        'CREATE INDEX `idx_courses_author` ON `courses` (`author`)',
      ],
    },
    {
      collection: 'modules',
      indexes: [
        'CREATE INDEX `idx_modules_course` ON `modules` (`course`)',
        'CREATE INDEX `idx_modules_order` ON `modules` (\n  `course`,\n  `order`\n)',
      ],
    },
    {
      collection: 'lessons',
      indexes: [
        'CREATE INDEX `idx_lessons_module` ON `lessons` (`module`)',
        'CREATE INDEX `idx_lessons_order` ON `lessons` (\n  `module`,\n  `order`\n)',
      ],
    },
  ];

  const getCollectionByName = async (name) => {
    // Try direct get by name first (PocketBase supports id or name)
    try {
      return await pb.collections.getOne(name);
    } catch (_) {
      // Fallback to listing when name lookup is not supported
      const all = await pb.collections.getFullList();
      const found = all.find((c) => c.name === name);
      if (!found) throw new Error(`Collection not found: ${name}`);
      return found;
    }
  };

  for (const t of targets) {
    const col = await getCollectionByName(t.collection);
    const current = Array.isArray(col.indexes) ? col.indexes : [];
    const toRemove = t.indexes.filter((i) => current.includes(i));

    if (toRemove.length === 0) {
      console.log(`  • ${t.collection}: no matching indexes to remove`);
      continue;
    }

    const updated = current.filter((i) => !toRemove.includes(i));
    await pb.collections.update(col.id, { indexes: updated });
    console.log(
      `  • ${t.collection}: removed ${toRemove.length} index(es)`,
    );
  }
};

export const down = async (pb) => {
  // Rollback operations: re-add the indexes removed in up()
  console.log('Rolling back migration: 2025-09-13T01-43-28-985Z');

  const targets = [
    {
      collection: 'courses',
      indexes: [
        'CREATE UNIQUE INDEX `idx_courses_slug` ON `courses` (`slug`)',
        'CREATE INDEX `idx_courses_status_visibility` ON `courses` (\n  `status`,\n  `visibility`\n)',
        'CREATE INDEX `idx_courses_author` ON `courses` (`author`)',
      ],
    },
    {
      collection: 'modules',
      indexes: [
        'CREATE INDEX `idx_modules_course` ON `modules` (`course`)',
        'CREATE INDEX `idx_modules_order` ON `modules` (\n  `course`,\n  `order`\n)',
      ],
    },
    {
      collection: 'lessons',
      indexes: [
        'CREATE INDEX `idx_lessons_module` ON `lessons` (`module`)',
        'CREATE INDEX `idx_lessons_order` ON `lessons` (\n  `module`,\n  `order`\n)',
      ],
    },
  ];

  const getCollectionByName = async (name) => {
    try {
      return await pb.collections.getOne(name);
    } catch (_) {
      const all = await pb.collections.getFullList();
      const found = all.find((c) => c.name === name);
      if (!found) throw new Error(`Collection not found: ${name}`);
      return found;
    }
  };

  for (const t of targets) {
    const col = await getCollectionByName(t.collection);
    const current = Array.isArray(col.indexes) ? col.indexes : [];
    const missing = t.indexes.filter((i) => !current.includes(i));
    if (missing.length === 0) {
      console.log(`  • ${t.collection}: no indexes to add`);
      continue;
    }
    const updated = [...current, ...missing];
    await pb.collections.update(col.id, { indexes: updated });
    console.log(`  • ${t.collection}: added ${missing.length} index(es)`);
  }
};

